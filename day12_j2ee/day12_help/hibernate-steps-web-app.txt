
Implementation steps : forward approach
1. create dynamic web project.
2. Add User library & add the same to deployment assembly.
3.  create hibernate.cfg.xml(copy from help folder & make necessary changes)  : location  : run-time classpath(Create <resources> (source folder)-- from IDE & store hibernate.cfg.xml) & for local validations copy hibernate3.dtd under <dtds> folder anywhere on the disk.

4. Identify persistence requirements & wrap it in POJO class
Features of Hib. based POJO/JPA based Entity
4.1 : public , pkged class, implements Serializable(not mandatory -- reco)
4.2 Must provide def. constr.(mandatory)
4.3 can supply optionally paramed constr.
4.4 declare private D.M , non-static ,non-transient---properties of POJO 
4.5 One property -- must be unique ID for POJO. --- Data type of property MUST be Serializable


5. Generate the POJO.hbm.xml : to desc. the mapping to the Hib. frmwork OR use hibernate annotations to avoid writing HBM document

5.5 Make an entry of POJO class in hibernate.cfg.xml -- for automatic persistence.


Annotation support from pkg : javax.persistence
Help for annotations :
5.1
1. Mark the entity or POJO class with @Entity annotation
@Entity : class level ---mandatory

2. @Table(name="table name") : class level annotation ---optional

3. @Id : can be field level OR getter  method level. ---mandatory
4. optional
@GeneratedValue(strategy=GenerationType.AUTO) --> id generator supplied by persistence  provider(app srvr's or ORM frmwork i.e hibernate) & not by DB
Mandatory Rule for Identifier property type---must be Serializable

5. @Column(name="col name ") --> not mandatory if same names

3,4,5 : applicable to Entity id property
6.@Column(name="upper-cased  col name") : for rest of prop to col names mapping(optional)	
eg : for additional @Column annotations (method level annotation)
@Entity
public class Flight implements Serializable {

@Column(updatable = false, name = "flight_name", nullable = false, length=50)
public String getName() { ... }



6. Run time steps : Hibernate configuration steps
6.1 Create the singleton inst. of the Hib. SF -- in HibernateUtils class.(using static init block) --
Steps 
1. Create org.hibernate.cfg.Configuration class inst &  configure the same.
eg Configuration cfg=new Configuration().configure();// creates empty cfg instance & then reads settings from hibernate.cfg.xml placed in run time class path.
2. Create new empty ServiceRegistryBuilder, apply setting from configuration & build associated Service Registry instance.
eg -- ServiceRegistry service=new ServiceRegistryBuilder().applySettings(cfg.getProperties()).buildServiceRegsitry();
3. Create SF by supplying service inst to the hib configuration
sf=cfg.buildSessionFactory(service);

6.2 Use Context Listener class : to load HibernateUtils class -- so that via static block , singleton inst of the SF will be ready. 
One SF inst. will be typically created per web-appln & it will be closed via the same listener class -- when the web-appln is closing down.
6.2 Create Hib sesion.(using openSession) -- typically just before CRUD.(from DAO layer)
6.3 beginTx
6.4 perform CRUD operations(eg : save/persist/delete/update/HQL)
6.5 if no errs : commit Tx & close the session.--in case of errs , rollback the tx. & close Hib seesion.



How -to develop web - appln listeners ---
1. Developing Context listeners
1.1 - 1 Create Java class - as a Context listener class - by imple javax.servlet.ServletContextListener i/f
1.2  Imple the methods :
1. void contextInitialized(ServletContextEvent sce) -- called auto by WC -- @ context start-up.
2.void contextDestroyed(ServletContextEvent sce) -- called auto by WC -- @ context reload / undeploy/server shut down

1.3 Register the listener class with WC---add entry to web.xml to register ContextListener class with WC.
OR use class level annotation
@WebListener


Objective 1 - simplest --- test hib frmwork -- using create part of 
1. CRUD logic (save method)
API (method) of org.hibernate.Session
public Serializable save(Object o) throws HibernateException

I/P  ---transient POJO ref.
save() method auto persists transient POJO on the DB(upon committing tx) & returns unique serializable ID generated by (currently) hib frmwork.


2. Hibernate session API -- for data retrieval
API (method) of org.hibernate.Session
public Object get(Class<?> c,Serializable id) throws HibernateException

Returns --- null -- if id is not found.
returns PERSISTENT pojo ref if id is found.



Usage of Hibernate Session API's get()
int id=101;
BookPOJO b1=(BookPOJO)hibSession.get(BookPOJO.class,id);

BookPOJO b1=(BookPOJO)hibSession.get(Class.forName("pojos.BookPOJO"),id);

2. disp all books info : using HQL -- Hibernate Query Language --- Objectified version of SQL --- where table names will be replaced by POJO class names & table col names will replaced by POJO property names.
(JPA--- Java Persistence API  compliant syntax --- JPQL ) 
eg --- HQL --- "select b from BookPOJO b"
2.1 Create Query Object --- from Session i/f
org.hibernate.Query --- public Query createQuery(String hql) throws HibernateException


2.2. Execute query to get List of selected PERSISTENT POJOs
API of Query i/f
 List<T> list();
T--- Type of POJO or Entity


 Usage ---
String hql="select b from BookPOJO b";
List<BookPOJO> l1=hibSession.createQuery(hql).list();


3. Passing IN params to query. & execute it.
Objective : Display all books from specified author , with price < specified price.
API from Query i/f
String hql="select b from BookPOJO b where b.price < :sp_price and b.author = :sp_auth";

List<BookPOJO> l1 = hibSession.createQuery(hql).setParameter("sp_price",user_price).setParameter("sp_auth",user_auth).list();


4. Updating POJOs --- Can be done either with select followed by update or ONLY with update queries(following is eg of 2nd option)
Objective : dec. price of all books with author=specified author.

4.5 

String hql = "update BookPOJO b set b.price = b.price - :disc where b.author = :au and b.publishDate < :dt ";
//set In params --exec it ---get rdy made populated book list				int updateCount= hs.createQuery(hql).setParameter("disc", disc).setParameter("dt", d1).executeUpdate();
						

5. Delete operations.
API of org.hibernate.Session
--void delete(Object object)  throws HibernateException 
---POJO is marked for removal , corresponding row from DB will be deleted after comitting tx & closing of session.

OR 
5.5 
One can use directly "delete HQL" & perform deletions.
eg 
int deletedRows = hibSession.createQuery ("DELETE Subscription s  WHERE s.subscriptionDate < :today").setParameter ("today", new Date ()).executeUpdate ();

API of org.hibernate.Query


1. Iterator iterate() throws HibernateException

Return the query results as an Iterator. If the query contains multiple results per row, the results are returned  Object[].

Entities returned --- in lazy manner

2. Query setMaxResults(int maxResults)

    Set the maximum number of rows to retrieve. If not set, there is no limit to the number of rows retrieved.

3.  Query setFirstResult(int firstResult)

    Set the first row to retrieve. If not set, rows will be retrieved beginnning from row 0. (NOTE row num starts from 0)

eg --- List<CustomerPOJO> l1=sess.createQuery("select c from CustomerPOJO c").setFirstResult(30).setMaxResults(10).list();


4. Object uniqueResult()  throws HibernateException

Returns a single instance that matches the query, or null if the query returns no results.
Throws:
    NonUniqueResultException - if there is more than one matching result




Annotations related to relationships(associations) between entities
0. one -----> one : unidirectional relationship.
In Customer Entity class ---

@OneToOne(cascade=CascadeType.ALL)
@JoinColumn(name="addr_id")  
private Address adr;
---owning side

In Address Entity --- no need of additional annotations.
name,email 
city,country






1. one 1 <----> one : bidirectional relationship.
@OneToOne(cascade=CascadeType.ALL,mappedBy="cust")  
private Address adr;
---owning side

@OneToOne
@JoinColumn(name="cust_id")
private Customer cust;

2. one 1 <---->* many : bi-directional
At one side : field level annotaion @OneToMany(cascade=CascadeType.ALL,mappedBy="propertyName in many side")
NOTE -- cascade is optional attribute. can be skipped .

At many side :
@ManyToOne
@JoinColumn(name="prim key column name of one side")

Meaning - Acts as Foreign key column referred from one side

eg -- Course 1----* Students
Table structure for understanding --- 
Course table --- course_id(PK),name,start_date,end_date,fees

Students table ---
id(PK),name,addr,course_id(FK)


@Id
@GeneratedValue(strategy=GenerationType.AUTO)
private int courseId;
.....
@OneToMany(cascade=CascadeType.ALL,mappedBy="myCourse")
private List<Student> students;

In Student POJO
@ManyToOne
@JoinColumn(name="courseId")
private Course myCourse;
	
	
	




Annotation for Date
@Temporal(TemporalType.DATE)
private Date startDate;
Creates date type of column in underlying DB(java.util.Date or java.util.Calendar or GC)
	

Annotation for Time
@Temporal(TemporalType.TIME)
private Date openingTime;
Creates time type of column in underlying DB

Annotation for TimeStamp
@Temporal(TemporalType.TIMESTAMP)
private Date closingDateTime;
Creates datetime type of column in underlying DB


More details on one ---many
The association may be bidirectional. In a bidirectional relationship, only one of the sides has to be the owner: ---  the owner is responsible for the association column(s) update.

To declare a side as not responsible for the relationship, the attribute mappedBy is used. mappedBy refers to the property name of the association on the owner side.  You MUST NOT declare the join
column since it has already been declared on the owners side.



Some more annotations
@Entity
@Table(name = "stock", catalog = "scott", uniqueConstraints = {
@UniqueConstraint(columnNames = "STOCK_NAME"),
@UniqueConstraint(columnNames = "STOCK_CODE") })


For Identity generator
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name="b_id")
	private int bookId;



------------------------
Steps for oracle
1.
create a sequence using PL-SQL ----
CREATE SEQUENCE my_seq
    MINVALUE 1
    START WITH 1
    INCREMENT BY 1
    CACHE 20;
2.In BookPOJO

@SequenceGenerator(name="seq_gen",sequenceName="my_seq")
	@Id
	@GeneratedValue(generator="seq_gen")
	@Column(name="book_id")
	private int bookId;

3. If book_id say has reached 30, & then u drop table & generate next row , it shows 31.
If u want to reset it to 1 ---drop sequence my_seq
& then it starts with id vals 1.....

LOB handling annotations
@Lob
private byte[] data;






